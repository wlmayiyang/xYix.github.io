---
title: UNR#4 题解 - 不含 D2T3
---

# D1T1 - 序列妙妙值

> **题目大意.**
>
> [原题意](https://uoj.ac/contest/55/problem/549)足够清晰了。

这不是某初赛程序填空（CSP-S2020）？？？

# D1T3 - 校园闲逛

> **题目大意.**
>
> [原题意](https://uoj.ac/contest/55/problem/551)足够清晰了。

容易写出
$$
A=\dfrac{I}{I-G}
$$
其中 $G$ 是转移矩阵。通过精细实现，尽量减少 DFT 即可做到 $O(n^3v+n^2v\log v)$。（是集合幂级数人最熟悉的卡 DFT 环节）

----

然而有一个神奇的做法：把多项式套在矩阵的外面而不是里面。你会发现 DFT 里面只有数乘操作，于是就直接 $O(n^3v+n^2v\log v)$ 了。

# D1T2 - 网络恢复

> **题目大意.**
>
> [原题意](https://uoj.ac/contest/55/problem/550)足够清晰了。

一看异或，大概是要随机化了。

把边分成 $50$ 组，对于每组，每个点期望分到 $1.2$ 条边，于是对于大多数点可以直接解析出唯一的边。

至于那些度数 $\ge 2$ 的点就是真·乱搞了。随机选一个点 $u$，然后对每个其他点都尝试解析 $B_v\operatorname{xor}A_u$，如果解析成功就说明 $v$ 是一个二度点且我们成功找到两条边。不断重复即可。

# D2T1 - 同构判定鸭

> **题目大意.**
>
> [原题意](https://uoj.ac/contest/56/problem/552)足够清晰了。

不妨把两张图缩成一个。记字符 $c$ 对应的所有边的转移矩阵为 $A_{c}$。那么"串 $s$ 为好串"可表达为
$$
(1,1,\ldots)\cdot A_{s_{|s|}}\cdot\ldots\cdot A_{s_1}\cdot(1,1,\ldots,-1,-1\ldots)^{T}=0
$$
其中最后一个矩阵恰有 $n_1$ 个 $1$，$n_2$ 个 $-1$。

因此，只要我们能搓出 $n_1+n_2$ 个线性无关的好 $\prod A_c\cdot (1,1,\ldots,-1,-1\ldots)^{T}$ 就能确定所有串都是好的。

然后是一个简单的观察：依次考虑长度为 $1,2,...$ 的串们。如果长度 $+1$ 没有使线性基的大小增加，那么下一层也一定不会增加。（简单来说：如果某个矩阵 $A$ 能被线性表为 $\sum \lambda_iB_i$，那它已经没有希望了，因为 $X\cdot A=\sum\lambda_i(X\cdot B_i)$，整层的矩阵全都没有希望自然就完蛋了）

于是，最短的坏串长度一定只有 $n_1+n_2$。

这有什么用呢？我们考虑哈希，处理出从 $u$ 出发长度为 $k$ 的所有串构成的集合的哈希值，然后就很好判定了。顺带一提，一个有趣的哈希方法是：

- 把字符看成 $3\times 3$ 的随机矩阵，字符串的哈希值是所有字符的乘积，字符串集合的哈希值是所有串的和。如果还不放心，可以把相同字符在不同位置的矩阵设成不同。

# D2T2 - 己酸集合

> **题目大意.**
>
> [原题意](https://uoj.ac/contest/56/problem/553)足够清晰了。

容易把题意转化为：求某直线下点的数量。

有个 $n^2\log n+q\log n$ 做法：离线，把直线按斜率排序，考虑当斜率增大时两个点的截距什么时候会相超过，也即所谓**击败点**。询问时二分即可。

你可能会想，每个点明明是独立的，为什么要用这个对 $n$ 依赖如此之大的算法？你是对的，只需要对点分块运行上述算法即可通过。

注意处理多点共线的阴间情形。



