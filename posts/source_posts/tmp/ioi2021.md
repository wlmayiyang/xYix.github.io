---
title: IOI2021 题解
---

我复活辣！

# D1T1 - 分糖果

> **题目大意.**
>
> 有 $n$ 个元素，每个元素 $a_i$ 有一个"容量" $c_i$，一开始元素全为 $0$。你要支持 $q$ 次操作：区间加一个整数 $v$（可以为负），然后每个元素与 $0$ 取 max，与 $c_i$ 取 min（这个过程下面称为**校正**）。
>
> 最后你要输出所有元素的值。
>
> $n,q\le 2\times10^5$。时限 4s。

硬分块即可，不多讲了。

---

然而有个十分合理的一只 log 做法：

想象每个元素对应一个下标相同却没有校正过程的"自由元素"，然后我们把原元素和其对应自由元素比较。问题就变成：

> 如何确定每个元素最后一次撞到上下边界是什么时候。

我们这里认为：初始状态算撞了一次下边界；从下边界横跳一下又碰到下边界不算是撞了两次，上亦然。

那么，两次撞边界之间的时间段中，对应自由元素的最大值和最小值之差必定 $\ge c_i$。而若某一时间段内，对应自由元素的最大值和最小值之差 $\ge c_i$，那么必定有至少两次撞击。

于是也就容易用线段树定位出倒数第二次撞击了，进而得出最后一次撞击。

又可见 $i$ 和 $i+1$ 所用的线段树是十分相似的，$i\leftarrow i + 1$ 时直接小修一下即可。

```cpp
//从马爷爷那里贺的厉害实现
#include<bits/stdc++.h>
using namespace std;

typedef vector<int> vec;
typedef long long ll;

const int maxn = 200005;

int n, m;
ll S;
vector<pair<int, int> > Q[maxn];

namespace SegT {
	struct node {
		ll vmax, vmin;
		ll lzy;
		node operator + (const node b) const {
			return (node){max(vmax, b.vmax), min(vmin, b.vmin), 0};
		}
		void add(const ll V) {
			vmax += V, vmin += V, lzy += V;
		}
	} T[maxn << 2];
	void pushdown(int x) {
		T[x << 1].add(T[x].lzy);
		T[x << 1 | 1].add(T[x].lzy);
		T[x].lzy = 0;
	}
	void update(int x, int l, int r, int L, int R, int V) {
		if (L <= l && r <= R) return T[x].add(V);
		pushdown(x);
		int mid = (l + r) >> 1;
		if (L <= mid) update(x << 1, l, mid, L, R, V);
		if (R > mid) update(x << 1 | 1, mid + 1, r, L, R, V);
		T[x] = T[x << 1] + T[x << 1 | 1];
	}
	ll query(int x, int l, int r, int C, ll qmin, ll qmax) {
		if (l == r) {
			if (T[x].vmax > S) {
				assert(S - qmin <= C);
				return S - qmin;
			}
			assert(C - (qmax - S) >= 0);
			return C - (qmax - S);
		}
		pushdown(x);
		int mid = (l + r) >> 1;
		ll  tqmin = min(qmin, T[x << 1 | 1].vmin), 
            tqmax = max(qmax, T[x << 1 | 1].vmax);
		if (tqmax - tqmin <= C)
			return query(x << 1, l, mid, C, tqmin, tqmax);
		return query(x << 1 | 1, mid + 1, r, C, qmin, qmax);
	}
}

vec distribute_candies(vec c_, vec l_, vec r_, vec v_) {
	n = c_.size(); m = l_.size();
	vec ans; ans.resize(n);
	for (int i = 0; i < m; i++)
		Q[l_[i]].emplace_back(i, v_[i]),
		Q[r_[i] + 1].emplace_back(i, -v_[i]);
	
	for (int i = 0; i < n; i++) {
		for (auto qaq : Q[i])
			S += qaq.second,
			SegT::update(1, 0, m, qaq.first + 1, m, qaq.second);
		if (SegT::T[1].vmax - SegT::T[1].vmin <= c_[i])
			ans[i] = S - SegT::T[1].vmin;
		else ans[i] = SegT::query(1, 0, m, c_[i], 0x3f3f3f3f3f3f3f3fLL, -0x3f3f3f3f3f3f3f3fLL);
	}
	return ans;
}
```

# D1T2 - 钥匙

> **题目大意.**
>
> 现有 $n$ 个房间、$m$ 条无向边和 $n$ 类钥匙。每个房间中都有一把钥匙；每条边都需要你拥有指定的钥匙才能通过（钥匙不消耗）。
>
> 如果你一无所有地出现在 $i$ 号房间（当然，你可以立即捡起 $i$ 号房间中的钥匙），称你能到达的房间集合为 $p(i)$。
>
> 求使 $|p(i)|$ 最小的 $i$。若有多个，请把它们全部输出。
>
> $n,m\le 3\times10^5$。

这个问题问的就很有猫腻，努力想一想和它相关的做法。

**观察 1.** 显然，如果 $u$ 能到达 $v$ 那么 $p(v)\subseteq p(u)$。于是，若 $|p(u)|$ 最小，那么对于任意 $v\in p(u)$ 必然有 $p(v)=p(u)$。

不妨考虑不断缩点，考虑完了所有的边

# D2T1 - 修改 DNA

题意懒得写了，思博题。

```cpp
#include<bits/stdc++.h>
using namespace std;

int S[100005][3][3];
int qaq(char c) {
	if (c == 'A') return 0;
	if (c == 'T') return 1;
	return 2;
}
int n;
void init(string a_, string b_) {
	n = a_.size();
	for (int i = 1; i <= n; i++) {
		for (int d1 = 0; d1 < 3; d1++)
		for (int d2 = 0; d2 < 3; d2++)
			S[i][d1][d2] = S[i - 1][d1][d2];
		S[i][qaq(a_[i - 1])][qaq(b_[i - 1])]++;
	}
}
int get_distance(int l, int r) {
	int s[3][3];
	for (int d1 = 0; d1 < 3; d1++)
	for (int d2 = 0; d2 < 3; d2++)
		s[d1][d2] = S[r + 1][d1][d2] - S[l][d1][d2];
	int ans = 0;
	for (int d1 = 0; d1 < 3; d1++)
	for (int d2 = d1 + 1; d2 < 3; d2++) {
		int w = min(s[d1][d2], s[d2][d1]);
		ans += w, s[d1][d2] -= w, s[d2][d1] -= w;
	}
	if (s[0][1] != s[1][2] || s[1][2] != s[2][0]) return -1;
	ans += 2 * s[0][1];
	if (s[1][0] != s[2][1] || s[2][1] != s[0][2]) return -1;
	ans += 2 * s[1][0];
	return ans;
}
```

# D2T2 - 地♂牢游♂戏

> **题目大意.**
>
> 现在有一个 $n + 1$ 个房间的**黑暗**且**深邃**的地牢，

$$
\sum_{i}\dfrac{x_i}{g(\mathbf x)}\dfrac{\part g(\mathbf x)}{\part x_i}=\dfrac{1}{g(\mathbf x)}\sum_{i}a_ix_i\prod_{j\neq i}(1+a_jx_j)
$$

说人话就是