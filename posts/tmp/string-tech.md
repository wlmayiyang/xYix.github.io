---
title: 字符串科技学习笔记 - 推理的胜利
---

草我为啥啥字符串科技都不会啊

为啥你们都会 Z-function 啊

# 一些记号

$\Sigma$ 表示字符集。

一个字符串 $s$ 是一个字符的有序序列 $(\sigma_1,\sigma_2,...,\sigma_{|s|})$，所有 $\sigma_i$ 均是字符集 $\Sigma$ 中的元素。

记 $s\left(i\right)$ 为 $s$ 的第 $i$ 个字符。

记 $s\left[l:r\right]$ 表示子串 $(\sigma_l,\sigma_{l+1},...,\sigma_r)$。有时把 $s\left[p:|s|\right]$ 简记为 $s\left[p:\right]$，$s\left[1:p\right]$ 简记为 $s\left[:p\right]$。

记两个字符串 $s,t$ 的首尾拼接为 $s+t$。

字符 $s$ 记为 $\mathbf s$。

# Trie

skip

# 自动机

skip

# KMP

## KMP / 定义和内容

记 $\Pi(j,i)$ 是一个条件，其内容为 $s\left[:j\right]=s\left[i-j+1:i\right]$。特别地，认为 $\Pi(0,i)$ 总是成立。

在某字符串 $s$ 上定义一个 $\pi$ 函数
$$
\pi(i)=\max_{j<i,\Pi(j,i)}j
$$
认为 $\pi(0)$ 没有定义。

为了找到求 $\pi$ 的高效算法，我们引入两个结论。

> **引理 1.**
>
> $\pi(i+1)\le \pi(i)+1$。

**证明.** 这是显然的，因为容易验证 $\Pi(j,i)$ 是 $\Pi(j+1,i+1)$ 的必要条件。$\blacksquare$

> **引理 2.**
>
> 对于满足 $\Pi(j,i)$ 的 $j$，一定有 $\Pi(j,\pi(i))$。

**证明.** 我们有 $\Pi(\pi(i),i)$，又因 $j\le \pi(i)$，故只需要注意到若 $s=t$ 则一定有 $s\left[l:r\right]=t\left[l:r\right]$ 便立即得证。$\blacksquare$

引理 2 非常有趣，它提示我们只要不断令 $i\leftarrow \pi(i)$ 便可遍历某串的所有满足 $\Pi(j,i)$ 的所有 $j$。

从而我们可以得到一个高效且简单的递推求解 $\pi$ 的算法：

- 若 $s\left(i+1\right)=s\left(\pi(i)+1\right)$，则直接令 $\pi(i+1)=\pi(i)+1$，而且根据**引理 1**这是一个上界，不需要进行其他操作。
- 否则，$\Pi(j+1,i+1)$ 的必要条件是 $\Pi(j,i)$，我们从大到小遍历依次检查即可。

这个算法被称为 **KMP 算法**。根据[均摊分析](https://xyix.gitee.io/posts/?page=2&postid=67)，整个算法的复杂度是 $O(|s|)$ 的。

## KMP / 应用

### KMP / 应用 / KMP 与周期

我们仔细地审视一下 $\pi$ 函数，容易得到以下的性质：

> **引理 3.**
>
> $s\left[:i\right]$ 总是 $s\left[:i-\pi(i)\right]$ 不断重复形成的串的一个前缀。特别地，如果存在整数 $k\ge 2$ 使得 $k(i-\pi(i))=i$，那么 $i-\pi(i)$ 是 $s\left[:i\right]$ 的最小**周期**。

字符串的周期的定义非常明确直观，不赘述了。这个引理的正确性是显然的。

> **引理 4.**
>
> $s\left[1:i\right]$ 不是任何 $j<\pi(i)$ 的 $s\left[1:j\right]$ 不断重复形成的串的前缀。

**证明.** 否则我们可以把 $\pi(i)$ 和 $j$ 取 $\text{gcd}$。$\blacksquare$

从而我们可以通过 $\pi$ 函数立即知道某个前缀的周期。

### KMP / 应用 / KMP 与匹配

> **问题.** 给出字符串 $s$ 和 $t$，求 $s$ 在 $t$ 中分别在何位置作为子串出现。

构造字符串 $s+(\$)+t$，其中 $\$$ 是一个不在 $s$ 和 $t$ 中出现的字符。求解该串的 $\pi$ 函数，若某位置满足 $\pi(i)=|s|$，便意味着 $s$ 在此处出现。

时间复杂度 $O(|s|+|t|)$。

当然也有另一个做法是，求解出 $s+(\$)$ 的 $\pi$ 函数，然后构建自动机 $v_i\xrightarrow{s\left(i+1\right)}v_{i+1},v_i\xrightarrow{\text{otherwise}}v_{\pi(i)}$，其中 $v_i$ 表示第 $i$ 个节点，$\rightarrow$ 表示单向边，其上的字符表示这条边附带的字符。然后把 $t$ 扔到上面跑就好了，每跑到一次 $v_{|s|}$ 便表示 $s$ 出现一次。

可以发现这两种做法本质没有区别。

# ACAM

现在我们试图在串集合 $S=\{s_1,s_2,...,s_m\}$ 上构造和之前的 $\pi$ 函数类似的对象。具体来说，我们希望构建的是一个和 KMP / 应用 / KMP 与匹配一节类似的自动机，当我们把某串 $t$ 放到上面跑时，可以得到 $S$ 中所有串的所有出现位置。

具体来说我们建出 $S$ 集合的 Trie 树，而之前的 $i,j$ 都改为指代字典树上的某个节点，记根到节点 $v_i$ 组成的那串字符为 $S_i$。定义
$$
\Pi(j,i)=S_j=S_i\left[|S_i|-|S_j|+1:\right]
$$
我们还是认为 $\Pi(0,i)$ 总是成立。

然后我们在这个字典树上定义一种小于等于号（也就自然定义了小于号）。以层数为第一关键字，以同一层从左到右为第二关键字即可。

然后仍定义
$$
\pi(i)=\max_{j<i,\Pi(j,i)}j
$$
原来的引理 1 和引理 2 仍几乎成立，只需要把引理 1 中的 $i$ 改为 $v_{i+1}$ 的父亲。

从而我们容易直接把原来的 KMP 算法移植到此处，注意构造时按新的小于等于关系遍历节点。

# Z 函数

所以为什么这个东西在国内被叫做扩展 KMP……明明看起来没什么关系

在字符串 $s$ 上定义
$$
z(i)=\max_{s\left[:j\right]=s\left[i:i+j-1\right]} j
$$

# 后缀数组