---
title: luoguP4339 题解 - [ZJOI2018]迷宫
---

啊，ZJOI2018，永远滴神！

> **题目大意.**
>
> 令字符集为 $0\sim m-1$。
>
> 称一个字符串合法，如果它看成一个 $m$ 进制数时能被 $k$ 整除。
>
> 要求最小的 $n$ 使得：存在一个大小为 $n$，每个点有 $m$ 条转移边的自动机，其中必须保证 $0$ 号点既是入口也是出口，且恰能识别所有合法串。
>
> $m,k\le 10^{18}$。

显然 $n=k$ 是可以的：每个节点代表一个模 $k$ 同余等价类，$i$ 号点的 $j$ 号转移边转移到的是 $im+j\bmod k$。接下来的问题就是怎么把这个自动机压缩。

**事实 0.** 两个点等价当且仅当它们每一对相同转移边到的点等价。

*那么我们为什么不认为所有点全都等价呢？*（智将）这可不是开玩笑，其实想想好像也很有道理。

问题在于：$0$ 号点是出口，这赋予了它**特殊性**。进一步发现，"某条转移边走到的是 $0$"也具有特殊性。更进一步有以下事实：

**事实 1.** 两个节点等价当且仅当它们走到 $0$ 的路径集合完全相同。一种有趣的看法是：*$0$ 是一切特殊性之源。*

下面是对于 **事实 1** 的解读。

> 定义 $u$ 的第 $r$ 阶**转移函数**为 $m^ru+\sum_{i=1}^rm^{r-i}x_i$，其中 $x_i$ 可理解为第 $i$ 步转移走的转移边。转移函数的零点显然就是 $u$ 走到 $0$ 的路径集合。
>
> 比较两个点 $u,v$ 的第 $r$ 阶转移函数。注意到由于后面的 $\Sigma$ 实际上不重地枚举了所有 $[0,m^r-1]$ 的整数，所以：如果 $m^ru\neq m^rv$ 且这两个转移函数其中之一有解，则 $u,v$ 必然不等价。
>
> 事实上，显然地，如果满足这个条件则 $u,v$ 必定等价，即我们得出了等价的充要条件。

显然，如果 $m^ru=m^rv$ 则必定有 $m^{r+1}u=m^{r+1}v$，所以我们不妨直接枚举 $r$，每次把 $m^ru=m^rv$ 的点合并起来，把那些方程有解的点扔掉。

好了，你已经完全搞懂了缩点的 spirit，接下来只需要对更多的 $m,k$ 手动试验来获得更完整的对各种 case 的认识。下面给出精确的式子。

```cpp
#include<bits/stdc++.h>
typedef __int128 iint;
using namespace std;

iint m;
iint gcd(iint a, iint b) {
    if (b == 0) return a;
    return gcd(b, a % b);
}
iint calc(iint h, iint d, iint k) { //h : 还剩的点数, d : 将要弃掉的点数
    if (h <= 0) return 0;
    iint g = gcd(m, k), k0 = k / g, m0 = m / g;
    if (g == 1) return 0; //无法进行任何合并
    if (h <= k0) return 0; //无法进行任何合并
    d *= m0;
    return h - k0 + calc(k0 - d, d, k0);
}

int main() {
    int T; scanf("%d", &T);
    while (T--) {
        long long m_, k_; scanf("%lld%lld", &m_, &k_);
        m = m_;
        printf("%lld\n", k_ - (long long)calc(k_ - 1, 1, k_));
    }
}
```



