---
title: luoguP4339 题解 - [ZJOI2018]迷宫
---

啊，ZJOI2018，永远滴神！

> **题目大意.**
>
> 令字符集为 $0\sim m-1$。
>
> 称一个字符串合法，如果它看成一个 $m$ 进制数时能被 $k$ 整除。
>
> 要求最小的 $n$ 使得：存在一个大小为 $n$ 的自动机恰能识别所有合法串。
>
> $m,k\le 10^{18}$。

显然 $n=k$ 是可以的，每个代表一个模 $k$ 同余等价类。接下来的问题就是怎么把这个自动机压缩。

**观察 0.** $0$ 号点具有特殊性（可以作为出口），所以一定压不了。

**观察 1.** 如果有两个点 $u,v$ 满足 $mu=mv$，那么它们到达的点其实是相同的，~~众所周知人是一切社会关系的总合，~~我们就自然可以把它们压起来。

**观察 2.** 那么显然如果 $\gcd(m,k)=1$ 我们一定压不了，否则所有非 $0$ 点都与和它相差 $k/\gcd(m,k)$ 的非 $0$ 点可以压。记 $d=\gcd(m,k)$。下面是第一次压缩后可以推测出的事实。

*事实 0.* 还剩 $k/d+1$ 个点：$1$ 个 $0$，剩下 $k/d$ 个等价类，大小几乎全为 $d$。

*事实 1.* $k$ 实际上在接下来可以被视为 $k/d$。

*事实 2.* 存在**多次缩点**。这很自然。但是要注意那个大小为 $d-1$ 的等价类，它对我们精确描述缩点过程有重要影响。下面我们开始留意它的行为。

*事实 3.* 观察如下 $m=2,k=16$ 的缩点过程。尤其注意红色部分的行为。
$$
{\color{red}0},1,2,3,4,5,6,7,{\color{red}8},9,10,11,12,13,14,15\\
\Downarrow\\
{\color{red}0,8},(1,9),(2,10),(3,11),{\color{red}(4,12)},(5,13),(6,14),(7,15)\\
\Downarrow\\
{\color{red}0,8,(4,12)},(1,5,9,13),{\color{red}(2,6,10,14)},(3,7,11,15)\\
{\color{red}0,8,(4,12),(2,6,10,14)},{1,3,5,7,9,11,13,15}
$$
发现了吗？$8$ 不和 $0$ 合并这点很好理解，但 $(4,12)$ 和 $8$ 的区别在哪里？答案是 $0$ 的特殊性"传染"给了 $8$，换而言之，"几步走到 $0$"也是一个特征。

好了，你已经完全搞懂了缩点的 spirit，下面给出精确的式子。

```cpp
#include<bits/stdc++.h>
typedef __int128 iint;
using namespace std;

iint m;
iint gcd(iint a, iint b) {
    if (b == 0) return a;
    return gcd(b, a % b);
}
iint calc(iint h, iint d, iint k) { //h : 当前可"支配"的点数, d : 将要"损失"的点数
    if (h <= 0) return 0;
    iint g = gcd(m, k), k0 = k / g, m0 = m / g;
    if (g == 1) return 0; //无法进行任何合并
    if (h <= k0) return 0; //无法进行任何合并
    d *= m0;
    return h - k0 + calc(k0 - d, d, k0);
}

int main() {
    int T; scanf("%d", &T);
    while (T--) {
        long long m_, k_; scanf("%lld%lld", &m_, &k_);
        m = m_;
        printf("%lld\n", k_ - (long long)calc(k_ - 1, 1, k_));
    }
}
```



