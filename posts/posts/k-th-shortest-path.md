---
title: k 短路及其延伸
---

# 1. k 短路

首先跑出每个点 $u$ 到汇 $T$ 的最短路，记为 $d(u)$。自然也就得出了原图的最短路树。下面所提到的“边”，如果没有特殊说明，都是非树边。

现有一个边**列表** $P$（[某些材料](https://oi-wiki.org/graph/kth-path/#k)中说是边集，这显然是错的，考虑环的情况易见）。自然地，它导出一条唯一的从 $S$ 至 $T$ 的路径。于是自然地，

> **引理 1.**
>
> $P$ 所代表的路径的权值为 $d(S)+\sum_{(u,v,w)\in P}w-d(v)+d(u)$。

那么问题就剩下怎么生成合法的 $P$。这个生成方法必须精心设计，首先它

- 必须能遍历所有合法边列表；
- 而且不会生成非法边列表；
- 而且以权值不降的顺序遍历合法边列表。

注意这组要求看着很自然但其实很强，强到可以直接导出结论：每个 $P$ 被生成的顺序就是它们权值的排序。

下面给出一个符合要求的算法。

> **算法 1.**
>
> 预先给所有边按权值不降的顺序排序，第二关键字可以任意取。下面我们说一条边*小/大于*另一条边都按的是此顺序。
>
> 初始时令 $P$ 为空。对于当前列表 $P$，记其“顶部”的边为 $(u,v,w)$。不断地把 $P$ 替换为下列二者中权值较小者。
>
> - 在 $(u,v,w)$ 后接上一条以某个以 $v$ 为祖先的点（包括 $v$）为起点的*最小*边。
> - 把 $(u,v,w)$ 换成一条能使 $P$ 合法且*大于* $(u,v,w)$ 的*最小*边。
> - 否则如果没有任何选择，回溯：删去 $(u,v,w)$。

直接可持久化可并堆即可。hint：支持 2 操作并不难，用 1 操作添加 $(u,v,w)$ 时复制当前可并堆即可。

代码🕊了

# 2. 延伸

这里所说的 k 短路问题的延伸，其实就是延伸算法 1 的思想：构造一个总是使得当前方案权值不降的调整法。这个调整法能自然地解决“所有方案中的第 $k$ 大”问题。

> **例题.**
>
> [数据删除]