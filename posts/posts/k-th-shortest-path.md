---
title: k 短路及其延伸
---

# 1. k 短路

首先跑出每个点 $u$ 到汇 $T$ 的最短路，记为 $d(u)$。自然也就得出了原图的最短路树。

现有一个边集 $P$。我们来下面说明：

> **引理 1.**
>
> 以 $P$ 为非树（最短路树）边的，从 $S$ 到 $T$ 的路径如果存在就必定唯一。

> **证明.**
>
> 沿着树边只能从某点走到它的祖先，从而我们将各边按其起始位置的深度串起来即可。
>
> （以后我们按此视角把 $P$ 看作一个边的列表。）

于是自然地，

> **引理 2.**
>
> $P$ 所代表的路径的权值为 $d(S)+\sum_{(u,v,w)\in P}w-d(v)+d(u)$。

那么问题就剩下怎么生成合法的 $P$。这个生成方法必须精心设计，首先它

- 必须能遍历所有合法边集；
- 而且不会生成非法边集；
- 而且以权值不降的顺序遍历合法边集。

注意这组要求看着很自然但其实很强，强到可以直接导出结论：每个方案被生成的顺序就是它们权值的排序。

下面给出一个符合要求的算法。

> **算法 1.**
>
> 预先给所有边按权值不降的顺序排序，第二关键字可以任意取。下面我们说一条边*小/大于*另一条边都按此顺序。
>
> 初始时令 $P$ 为空。对于当前边集 $P$，记其“顶部”的边为 $(u,v,w)$。不断地把 $P$ 替换为下列二者中权值较小者。
>
> - 把 $(u,v,w)$ 替换为一条同样以 $u$ 为起点的恰好*大于* $(u,v,w)$ 的边。
> - 在 $(u,v,w)$ 后接上一条以某个 $u$ 的祖先为起点的最*小*边。
> - 否则如果没有任何选择，删去 $(u,v,w)$。

# 2. 延伸

这里所说的 k 短路问题的延伸，其实就是延伸算法 1 的思想：构造一个总是使得当前方案权值不降的调整法。这个调整法能自然地解决“所有方案中的第 $k$ 大”问题。