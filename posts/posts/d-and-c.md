---
title: 分治学习笔记
---

老年选手⑧会打 LCT，爬了爬了

发现其他树分治我也⑧会，爬了爬了

发现分治我更⑧会，爬了爬了

# 树分治

## 重链剖分

skipped

## 长链剖分

处理树上 $k$ 级祖先问题。一个节点所在的 $k$ 级祖先所在的重链长度一定大于等于 $k$，所以预处理点的 $2^i$ 级祖先和所有完整长链，对于 $k$ 我们跳到最大的 $2^x\le k$ 级祖先，到长链上查即可。

## 全局平衡二叉树

树链剖分+线段树的两个 log 是从哪里来的呢，因为它把所有信息全塞进一棵线段树里，导致即使操作一个极短的重链也要重新从这个线段树上走一遍。

所以我们分别建线段树就好了。为了方便跳重链，我们还可以参考 LCT，线段树的根指向链头的父亲。

为了保证树高为 log，需要注意选择重链的带权（权为轻儿子大小之和 +1）重心作根。

## 点分治/边分治

通过找重心来分割树使得分治树的高度为 $O(\log)$。容易发现这和线段树的结构很像，边分治甚至还和线段树一样是二叉的，于是可以搞一些骚操作，比如可持久化/合并之类的。

注意边分治分治树的树高是 $O(\log_{1.5})$  的。

点分治也不是不能骚操作，但是多叉可能比较难搞。当然可以强行转成二叉（对儿子序列再次分治），但是树高还是 $O(\log_{1.5})$ 的。（考虑完全三叉树）

## LCT

LCT 就是用一堆 splay 维护链剖分，这个链剖分选的实链是随便决定的，而由于 splay 支持合并和分裂所以可以进行一个 Access 操作~~（那么问题来了无旋 treap 能不能写 LCT 呢）~~，即把某个点到根的所有虚边转为实边，这样它到根的链就变为一个 splay。

显然这个东西满地都是均摊，但是它就是 $\log n$ 的，小编也非常惊讶。

## dsu on tree

条件非常苛刻，几乎只能是子树查询，无修改。大概就是暴力，但是把重儿子放在最后一个处理，这样处理本树的时候可以重复利用重儿子的信息，使得分治树高度为 $\log$。

## AAA 树

~~阿阿阿树~~⑧会，鸽了

# 一般分治结构

## 线段树

skipped

## 平衡树

skipped

## CDQ 分治

**离线**，对于一个询问，各修改的贡献独立。中序遍历分治树，计算左到右的贡献。

## 整体二分

**离线**，询问可以二分。本质就是把所有询问丢到同一棵分治树上去。

可以支持修改。和询问一起丢上去就行了，注意维持当前二分区间中的操作在时间的意义上有序。

## 猫树

询问一个区间的信息，而且答案可以合并。结构和线段树一致，预处理各分治区间从 mid 向左向右的信息，询问时 $O(1)$ 找到那唯一一个同时向左右儿子递归的节点。

离线可以减小一些空间。

## 二进制分组

询问一个区间的信息，要支持动态延长序列，答案可以合并。本质是建不完整棵线段树~~就不建了~~，当某个区间满了的时候才处理它的信息。和线段树建树的复杂度相同。