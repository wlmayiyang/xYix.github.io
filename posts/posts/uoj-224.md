---
title: uoj#224 题解 - 【NOI2016】旷野大计算
---

> **题目大意.**
>
> 现在有八种操作：
>
> - **输入**一个数，作为该操作的返回值。
> - **输出**一个曾经某次操作的返回值。
> - 把曾经某两次操作的返回值**相加**，作为该操作的返回值。
> - 把曾经某次操作的返回值和由你指定的某常数**相加**，作为该操作的返回值。
> - 把曾经某次操作的返回值的**相反数**作为该操作的返回值。
> - 把曾经某次操作的返回值**乘以 $2^k$** 后返回。$k$ 是由你指定的常数。
> - 选定曾经某次操作的返回值，记其为 $x$。返回 $\dfrac{1}{1+e^{-x}}$。下图为该函数（下称 sigmoid）的图像，以供参考。
>
> <div style="width:50%;margin:auto"><img src="https://img.uoj.ac/problem/224/w.png" alt=""></div>
>
> 所有常数和运算结果只能精确到 ``1e-90``，超过的部分会被四舍五入。
>
> 你要以尽可能少的操作数完成下面的任务。

# Task 0

首先题目的输出格式过于反人类，所以一个好的想法是写个程序用类来维护它们。具体来说，我写的是

```cpp
#define fin return (node){++idx}
struct node {
    int id;
};
int idx;
node input() { printf("I\n"); fin; }
node output(const node u) { printf("O %d\n", u.id); fin; }
node operator + (const node u, const node v) { printf("+ %d %d\n", u.id, v.id); fin; }
node operator + (const node u, const char *s) { printf("C %d %s\n", u.id, s); fin; }
node operator << (const node u, const char *s) { printf("< %d %s\n", u, s); fin; }
node operator >> (const node u, const char *s) { printf("> %d %s\n", u, s); fin; }
node operator - (const node u) { printf("- %d\n", u); fin; }
node S(const node u) { printf("S %d\n", u); fin; }
string qaq_to_string(long long x) {
    string ans = "";
    while (x) {
        string del = " "; del[0] = '0' + x % 10;
        ans = del + ans;
        x /= 10;
    }
    if (ans == "") ans = "0";
    return ans;
}
```



# Task 1

> 给出两个实数 $a,b$，皆只精确到 ``1e-9``。要求输出 $-2a-2b$。

思博题不讲了。**6 步操作**。

# Task 2

> 给出一个实数 $a$，只精确到 ``1e-9``。要求输出 $\dfrac{1}{1+e^{17a}}$。

思博题不讲了。**6 步操作**。

# Task 5

> 给出一个 32 位整数的二进制表示，要求输出其十进制表示。

思博题不讲了。**95 步操作**。

# Task 3

> 给出一个实数 $a$，只精确到 ``1e-9``。求 $\text{sgn}(a)$。

注意到 sigmoid 的图像与 $\text{sgn}$ 近似，所以只需要把 $a$ 乘上一个极大的数再 sigmoid 即可。

加上一些线性变换，共 **6 步操作**。

# Task 4

> 给出一个实数 $a$，只精确到 ``1e-9``。求 $|a|$。

由于我们已经实现了 $\text{sgn}$ 函数，我们自然考虑实现 $(k\in\{0,1\})\cdot x$。

我们必须靠一系列函数嵌套来实现这个功能。似乎最关键的一层函数只能是 sigmoid。自然考虑在 sigmoid 上取两个点 $f_0(x)$ 和 $f_1(x)$，而且要保证

- $\text{sig}(f_1(x))$ 和 $x$ 有关，我们能从中还原出 $x$，其他一切好说。
- $\text{sig}(f_0(x))$ 是一个常数。

注意 sigmoid 靠近原点的一段，这……似乎近似于 $x$ 的一个线性变换！具体来说，我们泰勒展开 sigmoid，当 $x\rightarrow 0$ 时有
$$
\text{sig}=\dfrac 12+\dfrac 14x+o(x^3)
$$
于是，最终
$$
k\cdot x=4\cdot\left(\text{sig}(x\cdot p+(-1+k)\cdot\infty)/p-\dfrac 12\right)
$$
其中 $p$ 是一个较小数。

## Task 4 - 如何卡常

经过一顿卡常就可以达到 **14 步操作**。由于此处的卡常非常神秘但又没什么解释的必要，此处直接给出 ``4.out``。

```
I
C 1 0.000000000000000001
< 2 1000
S 3
< 4 202
> 1 200
+ 6 5
S 7
- 8
C 9 0.5
< 10 203
+ 1 11
+ 12 5
O 13
```

# Task 6

> 给出一个十进制整数 $u$，求它的二进制表示。不足 32 位补前导零。

显然我们暂时搞不出取模，但是判断一个数是否大于等于 $2^k$ 还是好做的，直接从高到低确定即可。

## Task 6 - 如何卡常

- 首先注意到 sgn 中有一个 ``<<`` 操作，这个可以直接分配律套到外面。
- 确定最低位时直接输出 $u$ 就行。
- 我们想要的其实不是 sgn 而是**非负函数**，于是一般人都会预先把 $u$ 加上 $0.1$，但是其实这个 $0.1$ 可以套在别的常数里，比如 $2^i$。

通过精妙的卡常可以卡到 **190 步操作**。

# Task 7

> 给出两个十进制数 $a,b$，求 $a\operatorname{xor}b$。

首先自然先把十转二二转十板子粘上去。考虑单位异或，我们只需要考虑 $x+y$ 然后掏出一个把 $0,2$ 映射到 $0$，把 $1$ 映射到 $1$ 的映射即可。显然我们只需要判出 $x=2$ 的情况并把它减去 $2$ 即可。

共 **603 步操作**。

# Task 8

> 给出一个实数 $a$，只精确到 ``1e-9``。求 $a/10$。

根据 Task 4 的经验，我们只需要找一个 $x_0$ 使得图像在此处斜率为 $1/10$ 即可。
$$
x_0=-\ln(4+\sqrt{15})
$$
只需 **7 步操作**。

# 总结

- 重要的不是什么东西**搞得出来**，而是什么东西**搞不出来**。