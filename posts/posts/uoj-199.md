---
title: uoj#199 题解 - 【CTSC2016】萨菲克斯·阿瑞
---

> **题目大意.**
>
> 对于所有长度为 $n$，字符集为 $1\sim m$，且字符 $i$ 出现了不超过 $c_i$ 的字符串做后缀排序，求有多少种不同的后缀数组。
>
> $n,m\le 500$。时限 5s。

我们用一个后缀的开头下标来代表它本身。记 $\text{RNK}(i)$ 为后缀 $i$ 的排名，$\text{SA}(i)$ 为排名为 $i$ 的后缀。

# 1. 后缀数组 $\Leftrightarrow$ 字符串 $\Leftrightarrow$ 不等式链

考虑后缀 $\text{RNK}(i)<\text{RNK}(j)$ 的两个后缀 $i,j$。我们自然要有 $s\left[i\right]\le s\left[j\right]$。

更进一步，$s\left[i\right]=s\left[j\right]$ 仅当 $\text{RNK}(i+1)<\text{RNK}(j+1)$ 或 $i=n$ 时才有可能。（下面我们在原串末尾加一个极小字符 $\$$，不再考虑这个特判。）

于是

> 一个 $\text{RNK}$ 导出一个 $s$ 上的小于 / 小于等于链。
>
> （注意我们强制要求 $s\left[n+1\right]$ 小于一切其他字符，即使推不出来。）

那么，满足某 $\text{RNK}$ 导出的小于 / 小于等于链的串是否总是一定导出 $\text{RNK}$？即，这条小于 / 小于等于链是否能还原出 $\text{RNK}$？

> **证明.**
>
> 我们比较两个后缀 $i,j$。
>
> - 如果 $s\left[i\right]<s\left[j\right]$ 或 $s\left[i\right]>s\left[j\right]$，那么胜负已分。
> - 否则 $s\left[i\right]\le s\left[j\right]$ 或 $s\left[i\right]\ge s\left[j\right]$，可以选择分出胜负或继续比 $s\left[i+1\right]$ 和 $s\left[j+1\right]$。
>
> 显然最终总会分出胜负（走到 $s\left[n+1\right]=\$$）；我们只需要说明 $i<j$ 和 $i>j$ 两种选择不可能同时存在。如果要达成这种诡异的情况，必须至少有一个 $\le$ 或 $\ge$，但是根据上面的说法，一旦你遇到了 $\le$，下一步就只能遇到 $\le$ 或 $<$，再也走不到 $\ge$ 和 $>$ 上了；反之亦然。
>
> **简而言之**：你以为给你留了那么多等号很自由，其实本质上你没有任何选择（悲）

这就证明了，

> **引理 1.**
>
> 一个小于 / 小于等于链*最多还原出一个 $\text{RNK}$*。
>
> 还原出一组不合法，比如 $i<j<k<i$，的后缀关系也就是有可能的。
>
> > 如果你想更好地把握这个命题，你可以使用以下事实：
> >
> > - ``1 2 3 (0)`` 引出 $(s_4<)s_1\le s_2<s_3$；
> >
> > - ``1 3 2 (0)`` 引出 $(s_4<)s_1<s_3\le s_2$；
> > - ``2 1 3 (0)`` 引出 $(s_4<)s_2<s_1<s_3$；
> > - ``2 3 1 (0)`` 引出 $(s_4<)s_3\le s_1<s_2$；
> > - ``3 1 2 (0)`` 引出 $(s_4<)s_2<s_3\le s_1$；
> > - ``3 2 1 (0)`` 引出 $(s_4<)s_3\le s_2\le s_1$。

于是我们获得一个重要工具：$\text{RNK}/\text{SA}$ 到不等式链的对应。

# 2. 不等式链的初步应用

我们自然会问，如何判定一个 $\text{RNK}/\text{SA}$ 也即一个保证合法的不等式链能被填出来。其实按不等式链贪心地填即可，遇到 $<$ 就强制换一个字符，这个策略显然是对的。

下面是关键的一步：我们考虑给每个 $\text{RNK}$ 钦定一个**标准填色**，枚举了标准填色也就数出了 $\text{RNK}$。自然会想到，让每一个 $<$ 恰好隔开一种颜色的这种填色很有研究价值。先辅助定义一个重要概念。

> **定义 1.**
>
> 我们定义一个 $\text{RNK}/\text{SA}$ 的**秩**为它对应的不等式链中的 $<$ 数量，包括 $s\left[n+1\right]$ 后面那个。例：``2 1 3 (0)`` 的秩为 $3$，这也是样例中字符集大小为 $2$ 时它无法被填出的原因。

# 3. 秩的基本性质

> **引理 2.**
>
> 秩为 $1$ 和秩为 $n$ 的长度为 $n$ 的 $\text{RNK}$ 都恰好有一个。

> **证明.**
>
> 他们都唯一确定了一条不等式链。另外，事实上有：
>
> - 秩为 $1$ 的 $\text{RNK}$ 为 $\{n,n-1,...\}$。
> - 秩为 $n$ 的 $\text{RNK}$ 为 $\{...,3,n-2,2,n-1,1,n\}$。

我们首先考虑恰有 $c_1$ 个 $1$，$c_2$ 个 $2$，……的情形。

但是就连这个也太难了，先来考虑在字符集大小为 $3$ 时计数有多少个秩为 $3$ 的 $\text{RNK}$。

> 对于某个特定秩为 $3$ 的 $\text{RNK}$，这实际上确定了其填色方案：
> $$
> 1\le1\le\ldots\le1<2\le2\le\ldots\le2<3\le3\le\ldots\le 3
> $$
> 于是我们枚举 $c_1+c_2+c_3\choose c_1,c_2,c_3$ 填色方案。诚然，这种填色方案导出的 $\text{RNK}$ 的秩必定不超过 $3$，但的确有可能导出秩为 $2$ 或 $1$ 的 $\text{RNK}$。
>
> 导出了秩为 $2$ 的 $\text{RNK}$ 是一种什么情况呢：你填的是
> $$
> 1\le1\le\ldots\le1<2\le2\le\ldots\le2<3\le3\le\ldots\le 3
> $$
> 但它满足的不等式链其实是
> $$
> 1\le1\le\ldots\le1\ {\color{red}\le}\ 2\le2\le\ldots\le2<3\le3\le\ldots\le 3
> $$
> 或者
> $$
> 1\le1\le\ldots\le1<2\le2\le\ldots\le2\ {\color{red}\le}\ 3\le3\le\ldots\le 3
> $$
> 其实也很容易数，第一种情况必能被 $c_1+c_2$ 个 $1$ 和 $c_3$ 个 $2$ 填出，第二种亦然，再考虑容斥掉
> $$
> 1\le1\le\ldots\le1\ {\color{red}\le}\ 2\le2\le\ldots\le2\ {\color{red}\le}\ 3\le3\le\ldots\le 3
> $$
> 的情况，就得到
> $$
> \boxed{{c_1+c_2+c_3\choose c_1,c_2,c_3}-{c_1+c_2+c_3\choose c_1,c_2+c_3}-{c_1+c_2+c_3\choose c_1+c_2,c_3}+1}
> $$

这就提供了一个思路，我们每次都只统计所有**“满秩”**的 $\text{RNK}$，这样就能做到不重不漏了。

注意此处的容斥对"先前情况"的依赖较小，我们可以从左到右枚举每个小于/小于等于号来**分步容斥**。

# 4. 加上限制？

注意到一个显然的困难：一个 $\text{RNK}$ 的标准填色可能不符合限制，但是在限制下可能的确是可以靠其他方式填出来的。

那么这个问题如何解决？玄学地说：其实我们可以把一组不被 $<$ 分隔的字符看作同一种字符，这样就又可以看成标准填色了。具体一点：其实就是 **2.** 中所说的那个贪心。

最后再组合上 **3.** 中的容斥就可以得到最终 DP 了。

# 5. 最终 DP

**4.** 中的叙述听起来非常抽象，但其实我们考虑这个问题就很明白了：仍是考虑分步容斥，那么两种字符间有几种关系？

- 最自然的情况，我们在它们中间钦定一个 $<$，这样它们就自然隔开了；
- 如果直到前一种字符用完都还是没有遇到，则我们可以选择把它们视为一种字符；
- 仍在这两种字符之间钦定一个 $<$，但这种情况是以容斥 case1 为目的，贡献不同。

显然设第一维为当前字符编号，第二维为当前字符串长度，第三维为当前"尚未固定"（没有被 $<$ 断掉，仍可以继续合并）的字符数。具体式子巨简单就不说了。

状态数为 $O(n^2m)$。转移可轻松优化至 $O(1)$。

```cpp
#include<bits/stdc++.h>
typedef long long ll;
using namespace std;

const int p = 1000000007;
struct Z{
	int x;
	Z(int x0=0):x(x0){}
}; 
int inline check(int x){return x>=p?x-p:x;}
Z operator +(const Z a,const Z b){return check(a.x+b.x);}
Z operator -(const Z a,const Z b){return check(a.x-b.x+p);}
Z operator *(const Z a,const Z b){return 1LL*a.x*b.x%p;}
Z operator -(const Z a){return check(p-a.x);}
Z& operator +=(Z &a,const Z b){return a=a+b;}
Z& operator -=(Z &a,const Z b){return a=a-b;}
Z& operator *=(Z &a,const Z b){return a=a*b;}

Z fac[505], ifac[505], inv[505];
void init() {
	fac[0] = fac[1] = ifac[0] = ifac[1] = inv[1] = 1;
	for (int i = 2; i < 505; i++)
		fac[i] = fac[i - 1] * i,
		inv[i] = -inv[p % i] * (p / i),
		ifac[i] = ifac[i - 1] * inv[i];
}

int n, m;
int c[505];

Z f[505][505], sf[505][505], ans;
Z calc(int j, int k, int l) {
	return sf[j][k] - sf[j - l][k - l];
}

int main() {
	init();
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i++) scanf("%d", &c[i]);
	f[0][0] = 1;
	for (int i = 1; i <= m; i++) {
		for (int j = 0; j <= n; j++)
		for (int k = 0; k <= j; k++)
			sf[j + 1][k + 1] = sf[j][k] + f[j][k], f[j][k] = 0;
		for (int j = 0; j <= n; j++)
		for (int k = 0; k <= j; k++) {
			f[j][0] += 1LL * ifac[k] * calc(j, k, min(c[i], k));
			if (j != n)
				f[j][k] -= calc(j, k, min(c[i] - 1, k));
		}
		ans += f[n][0];
	}
	printf("%d\n", ans * fac[n]);
}
```

