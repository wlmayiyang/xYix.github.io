---
title: 字符串学习笔记
---

草我为啥啥字符串科技都不会啊

为啥你们都会 Z-function 啊

# 一些记号

$\Sigma$ 表示字符集。

一个字符串 $s$ 是一个字符的有序序列 $(\sigma_1,\sigma_2,...,\sigma_{|s|})$，所有 $\sigma_i$ 均是字符集 $\Sigma$ 中的元素。

记 $s\left(i\right)$ 为 $s$ 的第 $i$ 个字符。

记 $s\left[l:r\right]$ 表示子串 $(\sigma_l,\sigma_{l+1},...,\sigma_r)$。有时把 $s\left[p:|s|\right]$ 简记为 $s\left[p:\right]$，$s\left[1:p\right]$ 简记为 $s\left[:p\right]$。

记两个字符串 $s,t$ 的首尾拼接为 $s+t$。

字符 $s$ 记为 $\mathbf s$。

# Trie

skip

# 自动机

skip

# KMP

## KMP / 定义和内容

记 $\Pi(j,i)$ 是一个条件，其内容为 $s\left[:j\right]=s\left[i-j+1:i\right]$。特别地，认为 $\Pi(0,i)$ 总是成立。

在某字符串 $s$ 上定义一个 $\pi$ 函数
$$
\pi(i)=\max_{j<i,\Pi(j,i)}j
$$
认为 $\pi(0)$ 没有定义。

为了找到求 $\pi$ 的高效算法，我们引入两个结论。

> **引理 1.**
>
> $\pi(i+1)\le \pi(i)+1$。

**证明.** 这是显然的，因为容易验证 $\Pi(j,i)$ 是 $\Pi(j+1,i+1)$ 的必要条件。$\blacksquare$

> **引理 2.**
>
> 对于满足 $\Pi(j,i)$ 的 $j$，一定有 $\Pi(j,\pi(i))$。

**证明.** 我们有 $\Pi(\pi(i),i)$，又因 $j\le \pi(i)$，故只需要注意到若 $s=t$ 则一定有 $s\left[l:r\right]=t\left[l:r\right]$ 便立即得证。$\blacksquare$

引理 2 非常有趣，它提示我们只要不断令 $i\leftarrow \pi(i)$ 便可遍历某串的所有满足 $\Pi(j,i)$ 的所有 $j$。这样的 $j$ 被称为 $s\left[:i\right]$ 的 **Border**。

从而我们可以得到一个高效且简单的递推求解 $\pi$ 的算法：

- 若 $s\left(i+1\right)=s\left(\pi(i)+1\right)$，则直接令 $\pi(i+1)=\pi(i)+1$，而且根据**引理 1**这是一个上界，不需要进行其他操作。
- 否则，$\Pi(j+1,i+1)$ 的必要条件是 $\Pi(j,i)$，我们从大到小遍历依次检查即可。

这个算法被称为 **KMP 算法**。根据[均摊分析](https://xyix.gitee.io/posts/?page=2&postid=67)，整个算法的复杂度是 $O(|s|)$ 的。

## KMP / 应用

### KMP / 应用 / KMP 与周期

我们仔细地审视一下 $\pi$ 函数，容易得到以下的性质：

> **引理 3.**
>
> $s\left[:i\right]$ 总是 $s\left[:i-\pi(i)\right]$ 不断重复形成的串的一个前缀。特别地，如果存在整数 $k\ge 2$ 使得 $k(i-\pi(i))=i$，那么 $i-\pi(i)$ 是 $s\left[:i\right]$ 的最小**周期**。

字符串的周期的定义非常明确直观，不赘述了。这个引理的正确性是显然的。

> **引理 4.**
>
> $s\left[1:i\right]$ 不是任何 $j<\pi(i)$ 的 $s\left[1:j\right]$ 不断重复形成的串的前缀。

**证明.** 否则我们可以把 $\pi(i)$ 和 $j$ 取 $\text{gcd}$。$\blacksquare$

从而我们可以通过 $\pi$ 函数立即知道某个前缀的周期。

### KMP / 应用 / KMP 与匹配

> **问题.** 给出字符串 $s$ 和 $t$，求 $s$ 在 $t$ 中分别在何位置作为子串出现。

构造字符串 $s+(\$)+t$，其中 $\$$ 是一个不在 $s$ 和 $t$ 中出现的字符。求解该串的 $\pi$ 函数，若某位置满足 $\pi(i)=|s|$，便意味着 $s$ 在此处出现。

时间复杂度 $O(|s|+|t|)$。

当然也有另一个做法是，求解出 $s+(\$)$ 的 $\pi$ 函数，然后构建**自动机** $v_i\xrightarrow{s\left(i+1\right)}v_{i+1},v_i\xrightarrow{\text{otherwise}}v_{\pi(i)}$，其中 $v_i$ 表示第 $i$ 个节点，$\rightarrow$ 表示单向边，其上的字符表示这条边附带的字符。然后把 $t$ 扔到上面跑就好了，每跑到一次 $v_{|s|}$ 便表示 $s$ 出现一次。

可以发现这两种做法本质没有区别。

# ACAM

现在我们试图把之前在单个字符串上定义的 $\pi$ 扩展到字典树上去，而之前的 $i,j$ 都改为指代字典树上的某个节点。记根到节点 $v_i$ 组成的那串字符为 $S_i$。定义

$$
\Pi(j,i)=S_j=S_i\left[|S_i|-|S_j|+1:\right]
$$
我们还是认为 $\Pi(0,i)$ 总是成立。

然后我们在这个字典树上定义一种小于等于号（也就自然定义了小于号）。以层数为第一关键字，以同一层从左到右为第二关键字即可。

然后仍定义
$$
\pi(i)=\max_{j<i,\Pi(j,i)}j
$$
原来的引理 1 和引理 2 仍几乎成立，只需要把引理 1 中的 $i$ 改为 $v_{i+1}$ 的父亲。

从而我们容易直接把原来的 KMP 算法移植到此处，注意构造时按新的小于等于关系遍历节点。

显然，使用 ACAM 可以解决**多串匹配问题**：只需要把模式串 $\{s_1,s_2,...\}$ 建出 ACAM 再把 $t$ 放上去跑即可。

# Z 函数

所以为什么这个东西在国内被叫做扩展 KMP……明明没什么关系

在字符串 $s$ 上定义
$$
z(i)=\max_{s\left[:j\right]=s\left[i:i+j-1\right]} j
$$

不妨把条件 $s\left[:j\right]=s\left[i:i+j-1\right]$ 记作 $\zeta(j,i)$。

> **引理 1.**
>
> 取 $j<i$ 且使得 $i-j+z(i-j+1)\le z(j)$ 的 $j$，定有 $z(i)\ge z(i-j+1)$。

**证明.** 
$$
\begin{aligned}s\left[:z(i-j+1)\right]&&\\&=s\left[i-j+1:i-j+z(i-j+1)\right]&(\zeta(z(i-j+1),i-j+1))\\&=s\left[i:i+z(i-j+1)-1\right]&(\zeta(z(j),j))\end{aligned}
$$
$\blacksquare$

> **引理 2.**
>
> 取 $j<i$ 且使得 $i\le z(j)+j-1$ 的 $j$，则定有 $z(i)\ge j+z(j)-i$。

证明略，几乎完全同上。

而我们计算 Z 函数的策略是，只使用一个 $j$ 来确认 $z(i)$ 的下界便足够了：使得 $j+z(j)-1$ 最大的 $j$。

- 如果是引理 2 或者 $z(j)+j-1< i$ 的情况，那么在确认该下界之后我们**暴力**不断检查 $z(i)$ 能否延长为 $z(i)+1$。注意到 $i$ 必然会成为新的 $j$，而最终 $i+z(i)$ 的大小是很有限的，因此这部分复杂度均摊 $O(1)$。
- 否则如果使用了引理 1：
- - 如果 $i+z(i-j+1)\le j+z(j)-1$，那么 $z(i)$ 不可能延长，否则 $z(i-j+1)$ 也可以延长。
  - 如果 $i+z(i-j+1)\ge j+z(j)-1$，那么 $i$ 也会成为新的 $j$，仍是暴力检查即可。

即我们成功证明了该算法的复杂度为 $O(|s|)$。

# 后缀数组

