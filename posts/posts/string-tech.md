---
title: 字符串学习笔记


---

草我为啥啥字符串科技都不会啊

为啥你们都会 Z-function 啊

# 目录

- 一些记号
- Trie
- 自动机
- KMP
- - 定义和内容
  - 应用
  - - KMP 与周期
    - KMP 与匹配
- ACAM
- Z 函数
- Manacher
- - 回文自动机
- 子序列自动机
- 后缀自动机

# 一些记号

$\Sigma$ 表示字符集。

一个字符串 $s$ 是一个字符的有序序列 $(\sigma_1,\sigma_2,...,\sigma_{|s|})$，所有 $\sigma_i$ 均是字符集 $\Sigma$ 中的元素。

记 $s\left(i\right)$ 为 $s$ 的第 $i$ 个字符。

记 $s\left[l:r\right]$ 表示子串 $(\sigma_l,\sigma_{l+1},...,\sigma_r)$。有时把 $s\left[p:|s|\right]$ 简记为 $s\left[p:\right]$，$s\left[1:p\right]$ 简记为 $s\left[:p\right]$。

记两个字符串 $s,t$ 的首尾拼接为 $s+t$。

字符 $s$ 记为 $\mathbf s$。

# Trie

skip

# 自动机

skip

# KMP

## KMP / 定义和内容

记 $\Pi(j,i)$ 是一个条件，其内容为 $s\left[:j\right]=s\left[i-j+1:i\right]$。特别地，认为 $\Pi(0,i)$ 总是成立。

在某字符串 $s$ 上定义一个 $\pi$ 函数
$$
\pi(i)=\max_{j<i,\Pi(j,i)}j
$$
认为 $\pi(0)$ 没有定义。

为了找到求 $\pi$ 的高效算法，我们引入两个结论。

> **引理 1.**
>
> $\pi(i+1)\le \pi(i)+1$。

**证明.** 这是显然的，因为容易验证 $\Pi(j,i)$ 是 $\Pi(j+1,i+1)$ 的必要条件。$\blacksquare$

> **引理 2.**
>
> 对于满足 $\Pi(j,i)$ 的 $j$，一定有 $\Pi(j,\pi(i))$。

**证明.** 我们有 $\Pi(\pi(i),i)$，又因 $j\le \pi(i)$，故只需要注意到若 $s=t$ 则一定有 $s\left[l:r\right]=t\left[l:r\right]$ 便立即得证。$\blacksquare$

引理 2 非常有趣，它提示我们只要不断令 $i\leftarrow \pi(i)$ 便可遍历某串的所有满足 $\Pi(j,i)$ 的所有 $j$。这样的 $j$ 被称为 $s\left[:i\right]$ 的 **Border**。

从而我们可以得到一个高效且简单的递推求解 $\pi$ 的算法：

- 若 $s\left(i+1\right)=s\left(\pi(i)+1\right)$，则直接令 $\pi(i+1)=\pi(i)+1$，而且根据**引理 1**这是一个上界，不需要进行其他操作。
- 否则，$\Pi(j+1,i+1)$ 的必要条件是 $\Pi(j,i)$，我们从大到小遍历依次检查即可。

这个算法被称为 **KMP 算法**。根据[均摊分析](https://xyix.gitee.io/posts/?page=2&postid=67)，整个算法的复杂度是 $O(|s|)$ 的。

## KMP / 应用

### KMP / 应用 / KMP 与周期

我们仔细地审视一下 $\pi$ 函数，容易得到以下的性质：

> **引理 3.**
>
> $s\left[:i\right]$ 总是 $s\left[:i-\pi(i)\right]$ 不断重复形成的串的一个前缀。特别地，如果存在整数 $k\ge 2$ 使得 $k(i-\pi(i))=i$，那么 $i-\pi(i)$ 是 $s\left[:i\right]$ 的最小**周期**。

字符串的周期的定义非常明确直观，不赘述了。这个引理的正确性是显然的。

> **引理 4.**
>
> $s\left[1:i\right]$ 不是任何 $j<\pi(i)$ 的 $s\left[1:j\right]$ 不断重复形成的串的前缀。

**证明.** 否则我们可以把 $\pi(i)$ 和 $j$ 取 $\text{gcd}$。$\blacksquare$

从而我们可以通过 $\pi$ 函数立即知道某个前缀的周期。

### KMP / 应用 / KMP 与匹配

> **问题.** 给出字符串 $s$ 和 $t$，求 $s$ 在 $t$ 中分别在何位置作为子串出现。

构造字符串 $s+(\$)+t$，其中 $\$$ 是一个不在 $s$ 和 $t$ 中出现的字符。求解该串的 $\pi$ 函数，若某位置满足 $\pi(i)=|s|$，便意味着 $s$ 在此处出现。

时间复杂度 $O(|s|+|t|)$。

当然也有另一个做法是，求解出 $s+(\$)$ 的 $\pi$ 函数，然后构建**自动机** $v_i\xrightarrow{s\left(i+1\right)}v_{i+1},v_i\xrightarrow{\text{if fail}}v_{\pi(i)}$，其中 $v_i$ 表示第 $i$ 个节点，$\rightarrow$ 表示单向边，其上的字符表示这条边附带的字符，如果没有该字符的转移边则不断跳 $\text{fail}$ 边。

然后把 $t$ 扔到上面跑就好了，每跑到一次 $v_{|s|}$ 便表示 $s$ 出现一次。容易观察到，这个自动机实际求解的是**模式** $s$ 和**文本** $t$ 的所有前缀 $t\left[i:\right]$ 的最长公共：$s$ 的前缀，$t\left[i:\right]$ 的后缀。

可以发现这两种做法本质没有区别。

# ACAM

现在我们试图把之前在单个字符串上定义的 $\pi$ 扩展到字典树上去，而之前的 $i,j$ 都改为指代字典树上的某个节点。记根到节点 $v_i$ 组成的那串字符为 $S_i$。定义

$$
\Pi(j,i)=S_j=S_i\left[|S_i|-|S_j|+1:\right]
$$
我们还是认为 $\Pi(0,i)$ 总是成立。（$0$ 表示字典树的根）

然后我们在这个字典树上定义一种小于等于号（也就自然定义了小于号）。以层数为第一关键字，以同一层从左到右为第二关键字即可。

然后仍定义
$$
\pi(i)=\max_{j<i,\Pi(j,i)}j
$$
原来的**引理 1**和**引理 2**仍几乎成立，只需要把**引理 1**中的 $i$ 改为 $v_{i+1}$ 的父亲。

从而我们容易直接把原来的 KMP 算法移植到此处，注意构造时按新的小于等于关系遍历节点。

显然，使用 ACAM 可以解决**多串匹配问题**：只需要把模式串 $\{s_1,s_2,...\}$ 建出 Trie 然后构造 ACAM 再把 $t$ 放上去跑即可。

# Z 函数

所以为什么这个东西在国内被叫做扩展 KMP……明明没什么关系

> **问题.** 求某个串 $s$ 的所有后缀和 $s$ 自身的最长公共前缀。

在字符串 $s$ 上定义
$$
z(i)=\max_{s\left[:j\right]=s\left[i:i+j-1\right]} j
$$

不妨把条件 $s\left[:j\right]=s\left[i:i+j-1\right]$ 记作 $\zeta(j,i)$。

> **引理 1.**
>
> 取 $j<i$ 且使得 $i-j+z(i-j+1)\le z(j)$ 的 $j$，定有 $z(i)\ge z(i-j+1)$。

**证明.** 
$$
\begin{aligned}s\left[:z(i-j+1)\right]&&\\&=s\left[i-j+1:i-j+z(i-j+1)\right]&(\zeta(z(i-j+1),i-j+1))\\&=s\left[i:i+z(i-j+1)-1\right]&(\zeta(z(j),j))\end{aligned}
$$
$\blacksquare$

> **引理 2.**
>
> 取 $j<i$ 且使得 $i\le z(j)+j-1$ 的 $j$，则定有 $z(i)\ge j+z(j)-i$。

证明略，几乎完全同上。

而我们计算 Z 函数的策略是，只使用一个 $j$ 来确认 $z(i)$ 的下界便足够了：使得 $j+z(j)-1$ 最大的 $j$。

- 如果是**引理 2**或者 $z(j)+j-1< i$ 的情况，那么在确认该下界之后我们**暴力**不断检查 $z(i)$ 能否延长为 $z(i)+1$。注意到 $i$ 必然会成为新的 $j$，而最终 $i+z(i)$ 的大小是很有限的，因此这部分复杂度均摊 $O(1)$。
- 否则如果使用了**引理 1**：
- - 如果 $i+z(i-j+1)\le j+z(j)-1$，那么 $z(i)$ 不可能延长，否则 $z(i-j+1)$ 也可以延长。
  - 否则 $i+z(i-j+1)\ge j+z(j)$，那么 $i$ 会成为新的 $j$，仍是暴力检查即可。

即我们成功证明了该算法的复杂度为 $O(|s|)$。

# Manacher

> **问题.** 求某个串 $s$ 的，以任意位置（可以是一个字符也可以是两个字符的间隙）为中心的**回文半径** $r$。回文半径是说，在这个范围之内均是回文串，在这个范围之外均是非回文串。

首先我们可以给 $s$ 中每两个字符中间插入一个 $\$$，这样就只需要考虑以字符为中心的情况了。

> **引理 1.**
>
> 取 $j<i$ 且 $i\le j+r(j)-1$，$r(i)\ge r(2j-i)$。

证明显然。

我想我甚至都不用再说下去了，直接就是 Z 函数经典复刻。

## Manacher / 回文自动机

容易发现上面的做法并不支持在线在序列末尾添加字符，为了支持它我们必须使用**回文自动机**。直观地说就是把上面的算法建成自动机：

- 每个节点都代表一个回文串
- 转移边表示在该串两边分别加同一个字符
- 如果文本串两边字符不同或者没有这种字符的转移边则 $\text{fail}$：连向该串的**最长回文后缀**。

可以发现如果把文本 $t$ 放到这个自动机上跑则可以求解出 $t$ 的所有前缀 $t\left[i:\right]$ 的最长的，在 $s$ 中出现过的回文后缀。

维护方法也就显然了，注意到在回文自动机上跳 $\text{fail}$ 会找到这个串的所有回文后缀，这和 KMP 自动机很像，直接复刻即可。

注意：回文自动机有 $|\Sigma|+1$ 个根，一种是空，剩下 $|\Sigma|$ 个分别表示仅有一个对应字符构成的串。

# 子序列自动机

> **问题.** 求 $s$ 和 $t$ 的最长公共：$s$ 的子序列，$t$ 的前缀。

子序列自动机的每一个节点代表**所有**以该位置结束的子序列，而每一条**路径**代表一个子序列。转移边就是贪心地跳到该字符下一次出现。在本问题中子序列自动机不允许 $\text{fail}$。

注意：当字符集极大时可能需要可持久化线段树来维护子序列自动机。

# 后缀自动机

> **问题.** 构造一个接受且仅接受所有 $s$ 的后缀的自动机，且要求节点数 $O(n)$。

如果把文本 $t$ 放到这个自动机上跑则可以求出所有 $t$ 的前缀 $t\left[i:\right]$ 和 $s$ 的最长公共后缀。

## 后缀自动机 / 定义和构建

后缀自动机实际上保存了所有本质不同子串。准确地来说，它把一些子串**压缩**成了一个节点来表示。

## 后缀自动机 / 应用

# 后缀数组

把 $s$ 的所有后缀 $\{s\left[i:\right]\}$ 按字典序排列：$\{s\left[\text{sa}_i:\right]\}$。记 $s\left[i:\right]$ 的排名为 $\text{rank}_i$。

## 后缀数组 / 经典做法

倍增基排。

## 后缀数组 / SA-IS

咕咕

## 后缀数组 / 应用

## 后缀数组 / 后缀平衡树

# Lyndon 科技

## Lyndon 科技 / Lyndon 分解

## Lyndon 科技 / Runs

